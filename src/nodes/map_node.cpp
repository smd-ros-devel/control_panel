/******************************************************************************
** map_node.cpp
**
** Author:      Matt Richard
** Date:        Nov 19, 2011
** Description: This ROS node receives the map generated by gmapping.
******************************************************************************/

#include "control_panel/nodes/map_node.h"

/******************************************************************************
** Function:    MapNode
** Author:      Matt Richard
** Parameters:  ros::NodeHandle *nh_ptr -
** Returns:     None
** Description: Constructor.
******************************************************************************/
MapNode::MapNode(ros::NodeHandle *nh_ptr)
{
	topic_name = Globals::DEFAULT_MAP_TOPIC;

	nh = nh_ptr;

    white = qRgb(255, 255, 255);
    black = qRgb(0, 0, 0);
    grey = qRgb(50, 50, 50);
}

/******************************************************************************
** Function:    subscribe
** Author:      Matt Richard
** Parameters:  None
** Returns:     void
** Description:
******************************************************************************/
void MapNode::subscribe()
{
	map_sub = nh->subscribe(topic_name, 1, &MapNode::mapCallback, this);
}

/******************************************************************************
** Function:    unsubscribe
** Author:      Matt Richard
** Parameters:  None
** Returns:     void
** Description:
******************************************************************************/
void MapNode::unsubscribe()
{
	map_sub.shutdown();
}

/******************************************************************************
** Function:    mapCallback
** Author:      Matt Richard
** Parameters:  const nav_msgs::OccupancyGridConstPtr &msg -
** Returns:     void
** Description:
******************************************************************************/
void MapNode::mapCallback(const nav_msgs::OccupancyGridConstPtr &msg)
{
    unsigned int i = 0;

    QImage buffer(msg->info.width, msg->info.height, QImage::Format_RGB888);
    buffer.fill(grey);

    //ROS_INFO("Origin:     (%f,%f,%f)\n", msg->info.origin.position.x,
    //    msg->info.origin.position.y, msg->info.origin.position.z);

    //ROS_INFO("Resolution: %f\n", msg->info.resolution);

    for(unsigned int y = 0; y < msg->info.height; y++)
    {
        for(unsigned int x = 0; x < msg->info.width; x++)
        {
            // Find (x,y) index into map data array
            i = x + (msg->info.height - y - 1) * msg->info.width;

            if(msg->data[i] == 0) // occupancy [0, 0.1)
                buffer.setPixel(x, y, white);
            else if(msg->data[i] == +100) // occupancy (0.65, 1]
                buffer.setPixel(x, y, black);
            //else // occupancy [0.1, 0.65]
            //    buffer.setPixel(x, y, grey);
        }
    }

    emit mapReceived(buffer);
}

/******************************************************************************
** Function:    setTopic
** Author:      Matt Richard
** Parameters:  std::string topic -
** Returns:     void
** Description:
******************************************************************************/
void MapNode::setTopic(const std::string &topic)
{
	topic_name = topic;
}

/******************************************************************************
** Function:    getTopic
** Author:      Matt Richard
** Parameters:  None
** Returns:     std::string - 
** Description:
******************************************************************************/
std::string MapNode::getTopic() const
{
	return topic_name;
}
